// Package oapigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.3 DO NOT EDIT.
package oapigen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Creates a new task
	// (POST /v1/tasks)
	CreateTask(w http.ResponseWriter, r *http.Request, params CreateTaskParams)
	// Deletes a task by name
	// (DELETE /v1/tasks/{name})
	DeleteTaskByName(w http.ResponseWriter, r *http.Request, name string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// CreateTask operation middleware
func (siw *ServerInterfaceWrapper) CreateTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateTaskParams

	// ------------- Optional query parameter "run" -------------
	if paramValue := r.URL.Query().Get("run"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "run", r.URL.Query(), &params.Run)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTask(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTaskByName operation middleware
func (siw *ServerInterfaceWrapper) DeleteTaskByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", chi.URLParam(r, "name"), &name)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter name: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTaskByName(w, r, name)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/tasks", wrapper.CreateTask)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/tasks/{name}", wrapper.DeleteTaskByName)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
