// Package oapigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.3 DO NOT EDIT.
package oapigen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Triggers a dryrun for a provided task
	// (POST /v1/dryrun/task)
	ExecuteTaskDryrun(w http.ResponseWriter, r *http.Request)
	// Creates a new task
	// (POST /v1/tasks)
	CreateTask(w http.ResponseWriter, r *http.Request, params CreateTaskParams)
	// Deletes a task by name
	// (DELETE /v1/tasks/{name})
	DeleteTaskByName(w http.ResponseWriter, r *http.Request, name string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// ExecuteTaskDryrun operation middleware
func (siw *ServerInterfaceWrapper) ExecuteTaskDryrun(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecuteTaskDryrun(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTask operation middleware
func (siw *ServerInterfaceWrapper) CreateTask(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateTaskParams

	// ------------- Optional query parameter "run" -------------
	if paramValue := r.URL.Query().Get("run"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "run", r.URL.Query(), &params.Run)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTask(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTaskByName operation middleware
func (siw *ServerInterfaceWrapper) DeleteTaskByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameter("simple", false, "name", chi.URLParam(r, "name"), &name)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter name: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTaskByName(w, r, name)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/dryrun/task", wrapper.ExecuteTaskDryrun)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/tasks", wrapper.CreateTask)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/tasks/{name}", wrapper.DeleteTaskByName)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"+lcAAAD//4VAv6UJHQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
